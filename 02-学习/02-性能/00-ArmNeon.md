
## [arm-neon内联函数查询](https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=)

## 1. 寄存器的名称

| version | 通用寄存器           | 备注           |
| ------- | -------------------- | -------------- |
| armv7   | 16x32bit/r0...r15    |                |
| armv8   | 31x64bit/x0...x31 | 32bit/w0...w30 |

| version | 向量寄存器         | 备注           |
| ------- | ------------------ | -------------- |
| armv7   | 16x128bit/q0...q15 | 64bit/d0...d31 |
| armv8   | 31x64bit/x0...x31  | 32bit/w0...w30 |

### 向量寄存器--armv7
`armv7 包含 16 个 128-bit 向量寄存器，用 q0-q15 表示，其中每个q寄存器又可以拆分成两个 64-bit 向量寄存器来用，用 d0-d31 来表示，对应关系: 

### 向量寄存器--armv8
`armv8 则有更多的向量寄存器，32个 128-bit 向量寄存器，用 v0-v31 来表示`
![[Pasted image 20230525190349.png]]
每个128-bit向量寄存器可以当做：
- 包含 2 个 64-bit 元素的向量寄存器来用，表达形式是 vn.2d；
- 包含 4 个 32-bit 元素的向量寄存器来用，表达形式是 vn.4s；
- 包含 8 个 16-bit 元素的向量寄存器来用，表达形式是 vn.8h；
- 包含 16 个 8-bit 元素的向量寄存器来用，表达形式是 vn.16b；
每个向量寄存器也可以只用低 64-bit：
- 1 个 64-bit 元素的向量寄存器来用，表达形式是 vn.1d；
- 2 个 32-bit 元素的向量寄存器来用，表达形式是 vn.2s；
- 4 个 16-bit 元素的向量寄存器来用，表达形式是 vn.4h；
- 8 个 8-bit 元素的向量寄存器来用，表达形式是 vn.8b；

## 内联汇编的格式

```cpp
__asm__ qualifiers ( 
    
    // 汇编代码部分

    : Outputs //在内联汇编代码中被修改的变量列表
    : Inputs  //在内联汇编代码中用到的变量列表
    : Clobbers       //在内联汇编代码中用到的寄存器列表
);
```

`qualifiers`：一般是用 `volatile` 修饰词

`Outputs`：在内联汇编中**会被修改的**变量列表，变量之间用','隔开,格式如下:
    [asm]  "=r"(c)
	
`InputOperands`：在内联汇编中用到的所有变量列表，变量之间用','隔开，格式如下:
    [asm]  "0.../r"(c)
    首先要按`Outputs`列表的顺序再列一遍，但是`""`中用数字代替从`0`开始，然后才是写其他只读变量，只读变量`constraint`填`r`

`Clobbers`：一般是`"cc"`，`"memory"`开头，然后接着填内联汇编中用到的通用寄存器和向量寄存器：
    - `"cc"`表示内联汇编代码修改了标志寄存器；
    - `"memory"`表示汇编代码对输入和输出操作数执行内存读取或写入操作,读写参数列表之一的变量指向的内存
